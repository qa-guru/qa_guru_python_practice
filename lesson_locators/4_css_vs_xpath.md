# Часть 4. Сравнение CSS-селекторов и XPath


## Ключевые возможности

| Возможность | CSS | XPath |
|------------|-----|--------|
| Поиск по тегу, классу, id, атрибутам | Да | Да |
| Частичное совпадение по атрибутам | `^`, `$`, `*` | `contains`, `starts-with`, `substring` |
| Поиск по тексту | Нет | Да: `text()`, `contains(text())`, `normalize-space()` |
| Навигация к родителю/предку | Нет | Да: `..`, `parent::`, `ancestor::` |
| Навигация к соседним элементам | Частично: `+`, `~` | Да: `following-sibling::`, `preceding-sibling::` |
| Индексация элементов | `:nth-child()`, `:nth-of-type()` | `[1]`, `[last()]`, `position()` |
| Логические условия | Ограничено | Полноценная поддержка: `and`, `or`, `not()` |
| Работа с узлами/текстовыми нодами | Ограниченно | Полная поддержка |
| Поддержка браузером | Нативно | Нативно |
| Работа с Shadow DOM | Ограниченно | Аналогично ограничено |



## Стабильность и поддерживаемость

### CSS
- проще читать и поддерживать;
- отлично сочетается со стабильными атрибутами:

### XPath
- позволяет выражать сложные условия;
- более гибок, но может получиться громоздким и хрупким, если переполнить путь условиями.


## Производительность
- CSS обычно обрабатывается быстрее, так как браузеры оптимизированы под него.
- XPath может быть медленнее при сложных выражениях, особенно в длинных списках.




## CSS рекомендуется, если:
- доступны стабильные атрибуты (`data-testid`, `data-qa`, `name`, `role`);
- не требуется поиск по тексту или анализ иерархии;
- важна краткость и скорость.

## XPath рекомендуется, если:
- нужен поиск по тексту;
- необходимо двигаться к родителям, соседям или предкам;
- отсутствуют уникальные атрибуты, а контекст можно определить через иерархию.

## Итог
- CSS — чаще всего основной инструмент: простой, быстрый, хорошо подходит для большинства задач.
- XPath — мощный инструмент для случаев, где нужна навигация по структуре или работа с текстом.

Правило по проекту: **сначала CSS через устойчивые атрибуты; если задача требует сложной логики — XPath**.