# Часть 5. Best Practices и антипаттерны


## Уникальность и точность
Локатор должен однозначно определять один конкретный элемент. Это снижает количество ошибок и повышает предсказуемость тестов.

**Примеры корректных локаторов:**
```css
[data-testid="signup-submit"]
```
```xpath
//*[@data-testid='signup-submit']
```

**Антипример:**
```css
button
.btn
```
Такие селекторы слишком широкие и приводят к множественным совпадениям.

---

## Стабильность локатора
Надёжный локатор не должен зависеть от:
- автоматически сгенерированных идентификаторов;
- временных или технических классов (`sc-abc123`, `react-select-*`);
- сложной структуры вложенности.

**Рекомендуется использовать устойчивые атрибуты:**
- `data-testid`, `data-qa`, `data-test`;
- `role`, `aria-*`;
- `name`, `type`.

---

## Краткость и читаемость
Локатор должен оставаться простым и понятным без необходимости дополнительного описания.

**Хорошо:**
```css
#email
input#email
```

**Плохо:**
```css
form > div:nth-child(2) > input#email
```

---

## Прозрачность выбора локатора
По локатору должно быть очевидно, почему выбран именно этот атрибут.
То есть он должен отображать суть элемента, который вы хотите использовать

**Хорошо:**
```css
[aria-label="Search"]
[data-qa="cart-icon"]
```

**Плохо:**
```xpath
//div[3]/div[2]/button[1]
```

---

## Минимальная зависимость от структуры
Структурные изменения вёрстки не должны ломать локатор. Избегайте привязки к индексам и глубокой вложенности.

**Хорошо:**
```css
.product-card [data-qa="buy"]
```

**Плохо:**
```css
#root > div > div:nth-child(2) > div > button
```

---

## Производительность
CSS-селекторы эффективны для большинства случаев. XPath стоит использовать, когда требуется:
- анализ текста;
- обращение к родителю, соседним элементам;
- сложный контекст.

---

## Независимость от языка интерфейса
Текстовые локаторы могут ломаться при смене языка. Предпочтительнее ориентироваться на стабильные атрибуты.

**Хорошо:**
```css
[data-qa="nav-login"]
```

**Риск:**
```xpath
//a[normalize-space(.)='Войти']
```

---

## Локализация области поиска
Сужение области поиска уменьшает количество совпадений и делает локатор понятнее.
При этом должны учитываться предыдущие пункты
```css
section.account [data-qa="logout"]
```

---

## Готовность элемента к взаимодействию
Локатор должен указывать на элемент, доступный для клика или взаимодействия.
Например: если нужно нажать на кнопку, то нужно искать тег `button`, если вы хотите ввести текст в поле - `input`
**Правильно:**
```css
button[type="submit"]
```

**Неправильно:**
```css
button > span
```

---

## Shadow DOM и iframe
- Для Shadow DOM использовать встроенные методы фреймворка.
- Для iframe необходимо предварительно переключиться в контекст кадра.

---

## Приоритет атрибутов
1. `data-testid`, `data-qa`, `data-test`
2. стабильный `id`
3. `name`, `role`, `aria-*`
4. устойчивые `class`, `href`, `type`, `value`
5. контекст родителя/соседей
6. текст — только при полной неизменности

---

## Строки: подстроки, экранирование и нормализация
При работе со строками необходимо:
- экранировать специальные символы в CSS;
- использовать `normalize-space()` для XPath;
- корректно работать с кавычками;
- при поиске по части текста, удостоверится что он будет уникальным 
Например: поиск подстроки `10%`, может найти `10%` и `0.10%` - что может привести к дефектам


## Консистентность проекта
- Единый стиль кавычек и оформление локаторов.
- Единая политика применения data-атрибутов.
- Все локаторы хранятся централизованно (PageObject, UI map).

## Работа с исчезающими элементами
Некоторые элементы (лоадеры, skeleton-блоки, спиннеры) существуют доли секунды. Это характерно для приложений на React, Vue, Angular.

### Рекомендации:
1. Ожидать исчезновение элемента, а не искать сам лоадер.
2. Ожидать изменение состояния контента.
3. Сравнивать количество элементов до и после действия.
4. Использовать **DOM breakpoints**.
5. 
---

## Быстрый чек-лист хорошего локатора
- локатор находит ровно один элемент.
- не зависит от динамических данных.
- включает только значимые части.
- использует стабильные атрибуты.
- не опирается на глубоко вложенную структуру.
- устойчив к мелким изменениям вёрстки.
- соответствует стилю проекта.
- легко проверяется через DevTools;
- прозрачен для код-ревью;
- должен содержать минимально необходимый, но достаточный контекст.